var ledgerTypes = (function (t) { var e = {}; function r (o) { if (e[o]) return e[o].exports; var n = e[o] = {i: o, l: !1, exports: {}}; return t[o].call(n.exports, n, n.exports, r), n.l = !0, n.exports } return r.m = t, r.c = e, r.d = function (t, e, o) { r.o(t, e) || Object.defineProperty(t, e, {enumerable: !0, get: o}) }, r.r = function (t) { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {value: 'Module'}), Object.defineProperty(t, '__esModule', {value: !0}) }, r.t = function (t, e) { if (1 & e && (t = r(t)), 8 & e) return t; if (4 & e && typeof t === 'object' && t && t.__esModule) return t; var o = Object.create(null); if (r.r(o), Object.defineProperty(o, 'default', {enumerable: !0, value: t}), 2 & e && typeof t !== 'string') for (var n in t)r.d(o, n, function (e) { return t[e] }.bind(null, n)); return o }, r.n = function (t) { var e = t && t.__esModule ? function () { return t.default } : function () { return t }; return r.d(e, 'a', e), e }, r.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, r.p = '', r(r.s = 0) }([function (t, e) {
  class r {
    constructor (t, e) { t instanceof Decimal ? this.value = t : this.value = new Decimal(`${t}`), this.commodity = e || '' } static create (t) {
      return t instanceof r ? t : new r(
      /**
 * @module ledger-types
 * @license MIT
 * @author zimmi
 */
        (function (t) { var e = new Decimal(0); return e.d = t.d, e.e = t.e, e.s = t.s, e }(t.value)), t.commodity)
    }hasSameCommodity (t) { return !(!t.hasOwnProperty('commodity') || this.commodity !== t.commodity) }add (t) { if (this.hasSameCommodity(t)) return new r(this.value.add(t.value), this.commodity) }sub (t) { if (this.hasSameCommodity(t)) return new r(this.value.sub(t.value), this.commodity) }mul (t) { if (this.hasSameCommodity(t)) return new r(this.value.mul(t.value), this.commodity) }div (t) { if (this.hasSameCommodity(t)) return new r(this.value.div(t.value), this.commodity) }equals (t) { if (this.hasSameCommodity(t)) return this.value.equals(t.value); throw new TypeError('Cannot compare amounts of different commodities') }greaterThan (t) { if (this.hasSameCommodity(t)) return this.hasSameCommodity(t), this.value.greaterThan(t.value); throw new TypeError('Cannot compare amounts of different commodities') }greaterThanOrEqualTo (t) { if (this.hasSameCommodity(t)) return this.hasSameCommodity(t), this.value.greaterThanOrEqualTo(t.value); throw new TypeError('Cannot compare amounts of different commodities') }lessThan (t) { if (this.hasSameCommodity(t)) return this.hasSameCommodity(t), this.value.lessThan(t.value); throw new TypeError('Cannot compare amounts of different commodities') }lessThanOrEqualTo (t) { if (this.hasSameCommodity(t)) return this.hasSameCommodity(t), this.value.lessThanOrEqualTo(t.value); throw new TypeError('Cannot compare amounts of different commodities') }
  } class o {constructor (t) { t instanceof r ? this[t.commodity] = t : Object.assign(this, t) } static create (t) { if (t instanceof o) return t; var e = new o({}); return Object.keys(t).forEach(o => { o.indexOf('_') === -1 && (e = e.add(r.create(t[o]))) }), e }addAmount (t) { var e = new o(this); return this.hasOwnProperty(t.commodity) ? e[t.commodity] = e[t.commodity].add(t) : e[t.commodity] = t, e }add (t) { if (t instanceof r) return this.addAmount(t); var e = new o(this); return Object.keys(t).forEach(r => { e = e.addAmount(t[r]) }), e }subAmount (t) { var e = new o(this); return this.hasOwnProperty(t.commodity) ? e[t.commodity] = e[t.commodity].sub(t) : e[t.commodity] = t.mul(new r(-1, t.commodity)), e }sub (t) { if (t instanceof r) return this.subAmount(t); var e = new o(this); return Object.keys(t).forEach(r => { e = e.subAmount(t[r]) }), e }mulAmount (t) { var e = new o(this); return this.hasOwnProperty(t.commodity) && (e[t.commodity] = e[t.commodity].mul(t)), e }mul (t) { if (t instanceof r) return this.mulAmount(t); throw new TypeError('Balances can only be multiplied by Amounts') }divAmount (t) { var e = new o(this); return this.hasOwnProperty(t.commodity) && (e[t.commodity] = e[t.commodity].div(t)), e }div (t) { if (t instanceof r) return this.divAmount(t); throw new TypeError('Balances can only be divided by Amounts') }equals (t) { var e = Object.keys(this); if (e.length !== Object.keys(t).length) return !1; var r = !0; return e.forEach(e => { t.hasOwnProperty(e) && this[e].equals(t[e]) || (r = !1) }), r }commodities () { return Object.keys(this).filter(t => !t.startsWith('_')) }} class n {constructor (t) { this.__bal = t || new o({}) } static create (t) { if (t instanceof n) return t; var e = new n(new o({})); return Object.keys(t).forEach(r => { r === '__bal' ? e.__bal = o.create(t[r]) : r.indexOf('_') === -1 && (e[r] = n.create(t[r])) }), e }_add (t, e) { for (var r, o = this; e.length > 0;)r = e.shift(), o.hasOwnProperty(r) ? o[r].__bal = o[r].__bal.add(t) : o[r] = new n(t), o = o[r] }_bal () { if (this.hasOwnProperty('__bal') && !this.__bal.equals(new o({}))) return this.__bal; var t = Object.keys(this); return this.__bal = new o({}), t.length > 0 && t.forEach(t => { t.startsWith('_') || (this.__bal = this.__bal.add(this[t]._bal())) }), this.__bal }} function i (t) { if (t.startsWith('P ')) { var e = t.substring(2, 12), r = e.split('/'); return e = `${r[1]}/${r[2]}/${r[0]} 00:00:00 GMT+00:00`, Date.now() >= new Date(e).getTime() } return !1 } const a = {parseCommodityPrice: function (t, e = 'GULD', o = 'USD') { var n, a; e = e.toUpperCase(), o = o.toUpperCase(), n = (t = t.split('\n').reverse()).filter(i); var s = `[0-9.]*[ ]{0,1}${o}$`.replace(e, ''); if ((a = new RegExp(s, 'm').exec(n.join('\n'))) && a.length > 0 && a[0].length > 0) { var m = a[0].replace(e, '').trim().replace(o, '').trim(); return new r(m, o) } throw new RangeError(`Price not found for commodity ${e}`) }}; t.exports = {Amount: r, Balance: o, Account: n, commodity: a}
}]))
